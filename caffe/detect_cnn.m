function score_matrix = detect_cnn(im, proposals, input_size, batch_size, num_class)
	% doing object detection using caffe
	% im: input image
	% configParams: proposals generated by random Prim's algorithm
	% input_size: size of input image fed into caffe
	% batch_size: size of images fed into caffe at once, see _deploy.prototxt
	% num_class: number of class to be classified
	% score_matrix: num_class-by-num_proposal matrix output by softmax
	
	N = size(proposals,1);
	epoch = ceil(N/batch_size);
	
	% prepare imgs for input
	imgs = prepareImgs(im, proposals, input_size, N);
	score_matrix = zeros(num_class, batch_size*epoch);
	
	tic;
	for e = 1:epoch
		input_data = zeros(input_size, input_size, 3, batch_size, 'single');
		start = (e-1)*batch_size + 1;
		if e == epoch
			last = N;
		else
			last = start + batch_size - 1;
		end
		input_data(:,:,:,1:last-start+1) = imgs(:,:,:,start:last);
		scores = caffe('forward', {input_data});
		score_matrix(:, (e-1)*batch_size+1:e*batch_size) = reshape(scores{1}, num_class, batch_size);
	end
	toc;
	score_matrix = score_matrix(:,1:N);
end

function imgs = prepareImgs(im, rect, input_size, N)
	% preprocessing the image for caffe input
	% im: image to be processed
	% rect: proposals generated by random Prim's algorithm
	% input_size: size of input image fed into caffe
	% N: number of proposals
	% imgs: image matrix after preprocessing
	
	% load the mean image, already in BGR
	load('intubation_mean.mat');
	MEAN_IMG = imresize(MEAN_IMG, [input_size input_size]);
	% note type must be single
	imgs = zeros(input_size, input_size, 3, N, 'single');
	% crop the proposals and resize into desired size
	for i = 1:N
		imgs(:,:,:,i) = imresize(im(rect(i,2):rect(i,4), rect(i,1):rect(i,3), :), [input_size input_size]);
	end
	% substract by mean image
	imgs = bsxfun( @minus, imgs(:,:,[3 2 1],:), MEAN_IMG );
	% convert from row-major into column-major, for C++ purpose
	imgs = permute(imgs, [2 1 3 4]);
end
